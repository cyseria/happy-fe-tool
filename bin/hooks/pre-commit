#! /usr/bin/env node

/**
 * @file git pre-commit hook Gitä»£ç æäº¤ä¹‹å‰å¯¹æ–‡ä»¶è¿›è¡Œæ£€æŸ¥å¹¶ä¿®å¤
 * @author Cyseria <xcyseria@gmail.com>
 * @created time: 2018-06-28 10:58:34
 * @last modified by: Cyseria
 * @last modified time: 2018-06-30 17:21:50
 */

const { execSync, exec, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

const IGNORE_FILENAME = '.fecsignore';

let fecs; // fecs çš„æ–‡ä»¶è·¯å¾„
let minimatch; // minimatch çš„æ–‡ä»¶è·¯å¾„
let moduleRoot = '';

console.log('\n====== ğŸ‘€ å¼€å§‹ä»£ç è§„èŒƒæ£€æŸ¥ ======');

if (hasDependencyVar('fecs')) { // å±€éƒ¨å®‰è£…
    moduleRoot = path.resolve(__dirname, '../..');
    console.log(moduleRoot)
    fecs = require(moduleRoot + '/node_modules/fecs');
    minimatch = require(moduleRoot + '/node_modules/minimatch');
    const files = getCheckFiles();
    fecsCheck(files);
} else if (hasGlobalVar('fecs')) { // å…¨å±€ fecs
    let root = ''

    // npm å®‰è£…è·¯å¾„
    try {
        const moduleRoot = execSync('npm root -g', { encoding: 'utf-8' }); // é»˜è®¤: /usr/local/lib/node_modules
        const fecsRoot = moduleRoot.trim() + '/fecs';
        const isExistsFecs = fs.existsSync(fecsRoot);
        if (!isExistsFecs) {
            throw new Error('npm æ‰¾ä¸åˆ° fecs');
        }
        fecs = require(fecsRoot);
        minimatch = require(fecsRoot + '/node_modules/minimatch');
    } catch (err) {
        // yarn å®‰è£…çš„è·¯å¾„
        try {
            const moduleRoot = execSync('yarn global dir', { encoding: 'utf-8' })
            const fecsRoot = moduleRoot.trim() + '/node_modules/fecs';
            const isExistsFecs = fs.existsSync(fecsRoot);
            if (!isExistsFecs) {
                throw new Error('yarn æ‰¾ä¸åˆ° fecs');
            }
            fecs = require(fecsRoot);
            minimatch = require(moduleRoot.trim() + '/node_modules/minimatch');
        } catch (err) {
            console.log('æ²¡æœ‰æ‰¾åˆ° fecs \nè¯·è¿è¡Œ `npm i fecs -g` å…¨å±€å®‰è£…æˆ– `npm i fecs -D` å±€éƒ¨å®‰è£…" ');
            process.exit(1);
        }
    }

    const files = getCheckFiles();
    fecsCheck(files);

} else { // æ£€æŸ¥æ˜¯å¦æœ‰å±€éƒ¨å®‰è£…
    console.log('ä½ è¿˜æ²¡æœ‰å®‰è£… fecs \nè¯·è¿è¡Œ `npm i fecs -g` å…¨å±€å®‰è£…æˆ– `npm i fecs -D` å±€éƒ¨å®‰è£…" ');
    process.exit(1);
}

function hasGlobalVar(v) {
    try {
        // æœ‰å…¨å±€ fecs è¿™ä¸ªå‘½ä»¤, å¯»æ‰¾è·¯å¾„
        const globalDir = execSync(`which ${v}`, {
            encoding: 'utf-8'
        });
        return true;
    } catch (err) {
        return false;
    }
}

function hasDependencyVar(v) {
    const moduleRoot = path.resolve(__dirname, '../..');
    const fecsRoot = path.resolve(moduleRoot, 'node_modules/fecs');
    return fs.existsSync(fecsRoot);
}

/**
 * è·å–éœ€è¦æ£€æŸ¥çš„æ–‡ä»¶
 */
function getCheckFiles() {
    let stagedFiles = '';
    try {
        // git diff-index --cached HEAD --name-only
        // diff-index æŸ¥çœ‹è¿ä¸ªç‰ˆæœ¬çš„ç´¢å¼• --cached æš‚å­˜åŒºï¼ˆaddï¼‰ --name-only åªæ˜¾ç¤ºæ–‡ä»¶å
        // HEAD æœ€è¿‘çš„ commit
        const result = execSync('git diff-index --cached --name-only HEAD', { encoding: 'utf-8' });
        if (!result) {
            console.log('****** æš‚å­˜åŒºæ²¡æœ‰æ–‡ä»¶ï¼Œè¯·æ·»åŠ åå†æäº¤ ******');
            process.exit(1);
        }

        // è¿˜æœ‰æ–‡ä»¶æœªæ·»åŠ 
        if (result.indexOf('Changes not staged for commit:') >= 0) {
            console.log(result);
            process.exit(1);
        }
        stagedFiles = stagedFiles || result.trim().split('\n');
        // å¿½ç•¥åˆ é™¤çš„ï¼ˆä¸å­˜åœ¨ï¼‰æ–‡ä»¶ï¼Œcommit åˆ é™¤çš„
        stagedFiles = stagedFiles.filter(function (file) {
            var filePath = path.resolve(__dirname, '../../', file);
            return fs.existsSync(filePath);
        })
        // å¿½ç•¥ fecs ä¸­å¿½ç•¥çš„æ–‡ä»¶
        stagedFiles = ignore(stagedFiles);
        return stagedFiles;

        // process.exit(1);
    } catch (err) {
        // ç¬¬ä¸€æ¬¡æäº¤æ²¡æœ‰æäº¤è®°å½•ï¼Œå°±æ²¡æœ‰ HEAD è®°å½•ï¼Œä¼šæŠ¥é”™
        // fatal: ambiguous argument 'HEAD': unknown revision or path not in the working tree.
        if (('' + err).indexOf('unknown revision') > 0) {
            console.log('ä»“åº“è¿˜æ²¡æœ‰æäº¤è®°å½•ï¼Œé»˜è®¤å¯¹æ‰€æœ‰æ–‡ä»¶è¿›è¡Œæ£€æŸ¥');
            stagedFiles = ['./**/*.{js,css,less,scss,html,vue}'];
            return stagedFiles;
        } else {
            console.log(err)
        }
    }
}

/**
 * åˆ é™¤ fecs ä¸­å¿½ç•¥çš„æ–‡ä»¶
 * @param  {Array} files æ–‡ä»¶åˆ—è¡¨
 * @return {Array} ä¿®æ”¹åçš„æ–‡ä»¶åˆ—è¡¨
 */
function ignore(files) {
    const ignoreFilePath = path.resolve(__dirname, '../../' + IGNORE_FILENAME);
    function valid(line) {
        line = line.trim();
        return line !== '' && line[0] !== '#';
    }
    try {
        const patterns = fs.readFileSync(ignoreFilePath, 'utf8').split(/\r?\n/).filter(valid);
        const filesArr = files.filter(filePath => {
            let result = false;
            patterns.forEach(pattern => {
                // å¯¹äºè¿‡æ»¤ *.foo è¿™æ ·çš„åç¼€æ–‡ä»¶, é‡‡ç”¨ minimatch
                const matches = minimatch(filePath, pattern) || minimatch(filePath, pattern + '/**');
                if (matches) {
                    result = true;
                    console.log('%s is ignored by %s.', filePath, '.fecsignore');
                }
            });
            return !result;
        });
        return filesArr;
    }
    catch (err) { // æ²¡æœ‰.fecsignore
        return files;
    }
}

/**
 * è¿è¡Œä»£ç æ£€æŸ¥
 * @param  {Array} files æ–‡ä»¶åˆ—è¡¨æ•°ç»„
 */
function fecsCheck(files) {
    var options = {
        color: true,
        rule: true,
        stream: false,
        lookup: true,
        level: 2,
        _: files
    };

    fecs.check(options, (success, json) => {
        success = success && json.length === 0;
        if (!success) {
            console.log('çœ‹æ¥è§„èŒƒè¿˜æœ‰é—®é¢˜ï¼Œè¯·ä¿®æ”¹ä»¥åå†æäº¤å§ï¼');
        }
        console.log('');
        process.exit(success ? 0 : 1);
    });
}